\documentclass{article}
\usepackage[top=1cm, bottom=1.5cm, left=1.5cm, right=1.5cm]{geometry}
\usepackage[ansinew]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}


\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{1,0,0}


\lstset{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
	numbers=left,
	frame=leftline,
	xleftmargin=42pt
}

\title{%
    \begin{minipage}\linewidth
        \centering \bfseries
        Rapport du projet XMLLiteParser
        \vskip3pt
        \large Modélisation
    \end{minipage}
}



\author{Mathis Deloge, Antoine Petot, Ange Picard}
\date{}


\begin{document}

% définition des style de puces
\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\circ$}
\renewcommand{\labelitemiii}{$-$}
\renewcommand{\labelitemiv}{$\triangleright$}


\maketitle

\section{Descriptif du sujet}
Un parseur / validateur XML-Lite est un programme capable de lire un fichier, d’indiquer s’il vérifie la norme XML-Lite et si oui, de l’analyser et de retenir sa structure ainsi que son contenu.
Pour nous permettre de concevoir un programme réalisable, notre parseur / validateur opère sur un langage simplifié de XML, le XML-Lite conçu pour faciliter l'utilisation, les performances ainsi que les normes de conformité (XML 1.0).

\subsection{Le XML-Lite}
Pour être considéré comme du XML-Lite, les fichiers parsés / validés par notre programme doivent respecter certaines règles :

\begin{itemize}
	\item Une balise possède un nom.
	\item Une balise doit être ouverte puis fermée.
	\item Une balise peut contenir du texte.
	\item Une balise peut contenir d'autre balises.
	\item L'ordre des balises filles n'a pas d'importance et tout le texte contenu dans une balise est regroupé en un seul bloc.
	\item Une balise fille doit être fermée avant la fermeture de la balise parent.
	\item Une balise peut contenir une balise du même nom.
	\item Un document doit commencer par l'ouverture d'une balise se fermant à la fin du document.
\end{itemize}

\subsection{Exemple de fichiers XML-Lite}

\subsubsection{Fichier XML-Lite correct}
\begin{lstlisting}
<FirstTag>
    <ChildTag>
	<AnotherChildTag>
        </AnotherChildTag>
    </ChildTag>
    <tag>
    </tag>
</FirstTag>
\end{lstlisting}

\subsubsection{Fichier XML-Lite invalide}
\begin{lstlisting}
  <FirstTag>
      <SecondTag>
	<EndTag>
	  <AloneTag>
	</>
  </FirstTag>
  </SecondTag>
Un peu de texte
\end{lstlisting}

\subsection{Structure du document}
Le parseur / validateur doit être capable de lire n'importe quel fichier XML-Lite mais doit aussi être en mesure d'attendre une certaine structure de document grâce à l'ajout d'un fichier .dtd appelé schéma.
Grâce aux fichiers schéma, le parseur / validateur connais avec plus de finesse les balises filles autorisées ou non pour chaque balises. C'est une sorte de modèle qui permettra la validation du fichier XML-Lite.

\newpage
\section{Journal de bord}

\subsection{Séance 1}
Lors de la première séance, nous avons tout d'abord effectué le choix de sujet. Le parseur / validateur XML-Lite nous a intéressé étant donné le grand nombre de programmes fonctionnant avec XML pour la persistance et la souplesse de ce format de base de données, nous étions intéressé de découvrir les notions de bases du XML.

\paragraph{}
Par ailleurs, durant cette séance, nous avons trouvé des informations sur les validateurs de documents et avons pensé à implémenter un automate fini pour modéliser notre validateur. Le design objet "state pattern" semblait particulièrement adapté.

\subsection{Séance 2}
Lors de la deuxième séance, nous avons modélisé l'automate fini schématiquement, puis, nous l'avons implémenté. Il est utilisé pour valider le document. Nous avons également codé les différents états.

\paragraph{}
\textbf{Exemple d'un état du validateur}

\begin{lstlisting}[language=java]
public class NewTag implements State {
    @Override
    public State transition(char c) {
        if (c == '/')
            return new NewClosingTag();
        else if ((c != '<') && (c != '>')) {
            XMLLiteParser.getInstance().fillBuffer(c);
            return new NewTagName();
        } else
            return new Error();
    }

    @Override
    public boolean isFinal() {
        return false;
    }
}
\end{lstlisting}

\paragraph{}
Puis, nous avons réfléchis à la structure mathématique du pasreur, nous sommes vite arrivé à celle d'un arbre. Cette structure à l'avantage d'être facile à designer en objet. Nous avons donc implémenté deux classes :

\begin{itemize}
	\item XMLLiteNode : Pour représenter une feuille ou un nœud de l'arbre.
	\item XMLLiteParser : Pour construire l'arbre.
\end{itemize}

\paragraph{}
Il a également fallu implémenter un buffer afin de stocker caractère par caractère les informations provenant des états du validateur.

\subsection{Séance 3}
Après avoir implémenté le parseur en structure d'arbre lors de la séance 2, nous avons pu interfacer une IHM basée sur les noeuds et feuilles de 
l'arbre nous permettant de faire une représentation claire et précise du fonctionnement du parseur / validateur qui nous serivra principalement 
lors de la présentation de projet.

\paragraph{}
L'implémentation de la classe JTree nous permet alors de représenter visuellement la structure du fichier XML-Lite analysé formaté en structure d'arbre.

\paragraph{}
Lors de cette séance, nous avons également mis en place un débogage à la volée des fichiers XML grâce à l’automate fini. Ainsi, on lève des exceptions quand il y a un problème avec l’arbre généré par nos états. Cela nous assure d’avoir en permanence un arbre cohérent ou une erreur le cas échéant.

\subsection{Séance 4}
Lors de la séance 4, nous avons dû faire face à une erreur n’arrivant uniquement lors de la lecture de gros fichiers. En effet, 
la validation de ces fichiers posait problème pour les dernières balises, le Parser rajoutait des balises filles au root node, à la fin, 
alors qu’elles n’existaient pas…
\paragraph{}
Nous avons pensé que ce problème provenait sans doute de notre classe qui lit les fichiers. Pour vérifier son fonctionnement, nous avons donc essayé de lire le fichier et de réécrire son contenu directement dans une copie. Et il est apparu qu’en effet, notre lecteur rajoutait des mauvais caractères en fin de fichier. Ceci a cause d’un buffer mal géré. Nous avons donc réécrit la classe de lecture des fichiers caractère par caractère avec des objets mieux adaptés.

\subsection{Temps personnel}
Nous avons réalisé les prolongements concernant la vérification de structure d’un document, la définition de cette structure dans un fichier (DTD) et l’interprétation d’un fichier XML.
\paragraph{}
Nous avons d’abord réalisé les objets représentants les contraintes. La première « contrainte » sert à représenter une contrainte (enfant autorisé, obligatoire) sur un nom de balise donnée.
\paragraph{}
Puis en implémentant un deuxième automate fini, mais cette fois-ci avec la syntaxe d’un DTD-Lite. Nous avons construit les contraintes à partir d’un fichier externe de la même manière que nous le faisions dans l’automate pour valider le XML. Mais cette fois-ci au lieu de construire un arbre, on construit un ensemble de contraintes qui définissent un schéma.
\paragraph{}
Nous avons ensuite construit un algorithme (récursif) qui s’occupe de parcourir l’arbre, et s’il trouve une balise qui porte un nom ayant une contrainte dans le schéma, de vérifier si ses balises filles respectent la dite contrainte.

\section{Choix du modèle mathématique}

\subsection{Le modèle mathématique}
La principale contrainte du validateur était de permettre la correspondance au modèle syntaxique du fichier XML-Lite.\\
Pour nous permettre de parcourir rapidement un fichier XML-Lite caractère par caractère, nous avons opté pour le développement d’un automate fini.

\paragraph{}
Enfin, ce modèle mathématique avec une implémantation et un débuggage relativement simple permet également une amélioration facile du programme
grâce à la différenciation de tous les états dans différentes classes.

\subsection{Représentation de l'automate fini}

\subsubsection{Schéma}

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                    semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[initial,state] (A)                    	{$I$};
  \node[state]         (B) [below of=A] 	{$FTO$};
  \node[state]         (C) [right of=B] 	{$NTN$};
  \node[state]         (D) [right of=C] 	{$ETN$};
  \node[state]         (E) [above right of=D]	{$TC$};
  \node[state]         (F) [below right of=D]	{$NT$};
  \node[state]         (G) [right of=F]		{$NCT$};
  \node[state]         (H) [right of=G]		{$CTN$};
  \node[state]         (I) [right of=H]		{$ECT$};
  \node[state]         (J) [below of=I]		{$F$};

  \path (A) edge              	node {<} (B)
        (B) edge		node {char} (C)
        (C) edge [loop above] 	node {char} (C)
            edge 		node {>} (D)
        (D) edge 		node {char} (E)
            edge              	node {<} (F)
        (E) edge [loop above] 	node {char} (E)
	    edge 		node {<} (F)
	(F) edge 		node {/} (G)
	    edge [bend left]	node {char} (C)
	(G) edge		node {char} (H)
	(H) edge [loop above] 	node {char} (H)
	    edge		node {>} (I)
	(I) edge [bend left] 	node {<} (F)
	    edge 		node {EOF} (J);
\end{tikzpicture}

\subsubsection{Description des états}

\begin{description}
	\item [I] Initial
	\item [FTO] First Tag Opening
	\item [NTN] New Tag Name
	\item [ETN] End Tag Name
	\item [TC] Text Content
	\item [NT] New Tag
	\item [NCT] New Closing Tag
	\item [CTN] Colsing Tag Name
	\item [ECT] End Closing Tag
	\item [F] Final
\end{description}

\newpage
\subsection{Automate de validation du fichier DTD}
Afin d'utiliser un fichier DTD, nous devons vérifier ce fichier DTD. Nous avons ainsi implémenter un automate fini pour vérifier la 
structure du schéma. 

\subsubsection{Schéma}

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
                    semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]

  \node[initial,state] (A)                    	{$I$};
  \node[state]         (B) [right of=A] 	{$OT$};
  \node[state]         (C) [right of=B] 	{$FS$};
  \node[state]         (D) [right of=C] 	{$TN$};
  \node[state]         (E) [right of=D]		{$SS$};
  \node[state]         (F) [below of=E]		{$OP$};
  \node[state]         (G) [below of=F]		{$CN$};
  \node[state]         (H) [below left of=G]	{$CC$};
  \node[state]         (I) [below right of=H]	{$NCP$};
  \node[state]         (J) [above right of=I]	{$CS$};
  \node[state]         (K) [below left of=F]	{$CP$};
  \node[state]         (L) [left of=K]		{$CT$};
  \node[state]         (M) [below left of=L]	{$F$};

  \path (A) edge		node {<!ELEMENT} (B)
        (B) edge		node {space} (C)
        (C) edge		node {char} (D)
        (D) edge [loop above]	node {char} (D)
            edge		node {space} (E)
            edge [bend left]	node {(} (F)
        (E) edge 		node {(} (F)
	(F) edge 		node {char} (G)
	    edge [bend left]	node {)} (K)
	(G) edge [loop right]	node {char} (G)
	    edge [bend right]	node {+} (H)
	    edge [bend right]	node {,} (I)
	    edge		node {)} (K)
	(H) edge [bend right]	node {,} (I)
	    edge		node {)} (K)
	(I) edge [bend right]	node {space} (J)
	    edge [bend right]	node {char} (G)
	(J) edge [bend right]	node {char} (G)
	(K) edge		node {>} (L)
	(L) edge [bend left]	node {<!ELEMENT} (B)
	    edge 		node {EOF} (M);   
	    
\end{tikzpicture}

\subsubsection{Description des états}

\begin{description}
	\item [I] Initial
	\item [OT] Opening Tag
	\item [FS] First Space
	\item [TN] Tag Name
	\item [SS] Second Space
	\item [OP] Opening Parenthesis
	\item [CN] Child Name
	\item [NCP] Next Child Point
	\item [CS] Child Space
	\item [CP] Closing Parenthesis
	\item [CT] Closing Tag
	\item [F] Final
\end{description}

\section{Conclusion}
\subsection{Les outils acquis}
\subsection{Les difficultés rencontrées}

\newpage
\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\end{document}